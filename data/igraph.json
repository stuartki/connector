[{"title": "g = Graph()", "type": ["definition"], "description": "g = Graph() creates graph with __init__.py ", "keywords": [], "past": [], "future": [2, 3, 4, 5, 6, 11, 12, 13, 21, 29, 30], "id": 1, "related": []}, {"title": "print(g)", "type": ["definition"], "description": "print(g) consists of IGRAPH, followed by a four-character long code, the number of vertices, the number of edges, two dashes (\u2013) and the name of the graph (i.e. the contents of the name attribute, if any) ", "keywords": [], "past": [1], "future": [], "id": 2, "related": []}, {"title": "g.add_vertices(int)", "type": ["definition"], "description": "g.add_vertices(int) adds the given number of vertices to the graph ", "keywords": [], "past": [1, 5], "future": [7], "id": 3, "related": []}, {"title": "g.add_edges([(int1, int2)])", "type": ["definition"], "description": "g.add_edges([(int1, int2)]) uses integer vertex IDs starting from zero, the first vertex of your graph has index zero, etc. with pairs of integers ", "keywords": [], "past": [1, 6], "future": [7], "id": 4, "related": []}, {"title": "vertices ", "type": ["definition"], "description": "vertices ", "keywords": [], "past": [1], "future": [3, 7, 9, 10, 19, 22, 24, 27, 28, 35], "id": 5, "related": []}, {"title": "edges ", "type": ["definition"], "description": "edges ", "keywords": [], "past": [1], "future": [4, 7, 8, 10, 19, 22, 25, 27, 36], "id": 6, "related": []}, {"title": "Vertex and edge IDs are always continuous, and a direct consequence of this fact is that if you happen to delete an edge, chances are that some (or all) of the edges will be renumbered ", "type": ["implication"], "description": "Vertex and edge IDs are always continuous, and a direct consequence of this fact is that if you happen to delete an edge, chances are that some (or all) of the edges will be renumbered ", "keywords": [], "past": [5, 6, 3, 4, 8, 9], "future": [], "id": 7, "related": []}, {"title": "g.delete_edges(int)", "type": ["definition"], "description": "delete_edges() deletes a list of edge IDs ", "keywords": [], "past": [6], "future": [7], "id": 8, "related": []}, {"title": "g.delete_vertices(int)", "type": ["definition"], "description": "delete_vertices(int) deletes vertex IDs ", "keywords": [], "past": [5], "future": [7], "id": 9, "related": []}, {"title": "g.get_eid(int1, int2)", "type": ["definition"], "description": "get_eid(int1, int2) gets ID of edge from IDs of the vertices at endpoints ", "keywords": [], "past": [5, 6], "future": [], "id": 10, "related": []}, {"title": "g.summary()", "type": ["definition"], "description": "summary()  ", "keywords": [], "past": [1], "future": [], "id": 11, "related": []}, {"title": "graph generators  ", "type": ["definition"], "description": "graph generators  ", "keywords": [], "past": [1], "future": [], "id": 12, "related": []}, {"title": "graph generators", "type": ["definition"], "description": "graph generatorrs ", "keywords": [], "past": [1], "future": [14, 15], "id": 13, "related": []}, {"title": "deterministic generators ", "type": ["definiiton", "definition"], "description": "deterministic generators ", "keywords": [], "past": [13], "future": [16, 18], "id": 14, "related": []}, {"title": "stochastic generators ", "type": ["definition"], "description": "stochastic generators ", "keywords": [], "past": [13], "future": [17, 20], "id": 15, "related": []}, {"title": "include methods for creating trees, regular lattices, rings, extended chordal rings ", "type": ["implication"], "description": "include methods for creating trees, regular lattices, rings, extended chordal rings ", "keywords": [], "past": [14], "future": [], "id": 16, "related": []}, {"title": "include methods to create Erdos-Renyi random networks, Barabasi-Albert networks, geometric random graphs ", "type": ["implication"], "description": "include methods to create Erdos-Renyi random networks, Barabasi-Albert networks, geometric random graphs ", "keywords": [], "past": [15], "future": [], "id": 17, "related": []}, {"title": "g = Graph.Tree(int_vertices, int_children) ", "type": ["definition"], "description": "g = Graph.Tree(int_vertices, int_children) ", "keywords": [], "past": [14], "future": [], "id": 18, "related": []}, {"title": "g.get_edgelist()", "type": ["definition"], "description": "g.get_edgelist() return a list that contains pairs of integers, one for each edge. The first member of the pair is the source vertex ID and the second member is the target vertex ID of the corresponding edge. ", "keywords": [], "past": [5, 6], "future": [], "id": 19, "related": []}, {"title": "g = Graph.GRG()", "type": ["definition"], "description": "g = Graph.GRG() generates a geometric random graph: n points are chosen randomly and uniformly inside the unit square and pairs of points closer to each other than a predefined distance d are connected by an edge ", "keywords": [], "past": [15], "future": [], "id": 20, "related": []}, {"title": "g.isomorphic()", "type": ["definition"], "description": "g.isomorphic() tells you whether two graphs are isomorphic or not. In general, it might take quite a lot of time, especially for large graphs, but in our case, the answer can quickly be given by checking the degree distributions of the two graphs ", "keywords": [], "past": [1], "future": [], "id": 21, "related": []}, {"title": "attributes", "type": ["definition"], "description": "attributes are auxillary objects associated to a given vertex or edge of a graph ", "keywords": [], "past": [5, 6], "future": [23, 24, 25], "id": 22, "related": []}, {"title": "saving graphs to a file, only string and numeric attributes will be kept", "type": ["implication"], "description": "if you are saving graphs to a file, only string and numeric attributes will be kept. See the pickle module in the standard Python library if you are looking for a way to save other attribute types en ", "keywords": [], "past": [22], "future": [], "id": 23, "related": []}, {"title": "g.vs", "type": ["definition"], "description": "g.vs is the sequence of all vertices ", "keywords": [], "past": [5, 22], "future": [26], "id": 24, "related": []}, {"title": "g.es", "type": ["definition"], "description": "g.es is the sequence of all edges ", "keywords": [], "past": [6, 22], "future": [26], "id": 25, "related": []}, {"title": "you can simply alter the attributes of vertices and edges individually by indexing vs or es with integers as if they were lists ", "type": ["implication"], "description": "you can simply alter the attributes of vertices and edges individually by indexing vs or es with integers as if they were lists ", "keywords": [], "past": [24, 25], "future": [], "id": 26, "related": []}, {"title": "vertex degree g.degree()", "type": ["definition"], "description": "g.degree(type=\"in\", \"out\") is the vertex degree ", "keywords": [], "past": [5, 6], "future": [28], "id": 27, "related": []}, {"title": "can call with vertex ID to g.degree(int) to get degree of certain or subset of vertices ", "type": ["implication"], "description": "can call with vertex ID to g.degree(int) to get degree of certain or subset of vertices ", "keywords": [], "past": [27, 5], "future": [], "id": 28, "related": []}, {"title": "g.evcent() is eigenvector centrality ", "type": ["definition"], "description": "g.evcent() is eigenvector centrality ", "keywords": [], "past": [1, 30], "future": [], "id": 29, "related": []}, {"title": "centrality ", "type": ["definition"], "description": "centrality ", "keywords": [], "past": [1], "future": [31, 29, 32, 33], "id": 30, "related": []}, {"title": "g.betweenness() is betweenness centrality", "type": ["definition"], "description": "g.betweenness() is betweenness centrality ", "keywords": [], "past": [30], "future": [], "id": 31, "related": []}, {"title": "g.edge_betweenness() is edge betweenness centrality ", "type": ["definition"], "description": "g.edge_betweenness() is edge betweenness centrality ", "keywords": [], "past": [30], "future": [], "id": 32, "related": []}, {"title": "g.pagerank()", "type": ["definition"], "description": "g.pagerank() is Google's PageRank ", "keywords": [], "past": [30], "future": [], "id": 33, "related": []}, {"title": "g.vs.select()", "type": ["definition"], "description": "g.vs.select() filters VertexSeq based on the propeprties of individual vertices ", "keywords": [], "past": [35], "future": [37], "id": 34, "related": []}, {"title": "VertexSeq ", "type": ["definition"], "description": "VertexSeq ", "keywords": [], "past": [5], "future": [34], "id": 35, "related": []}, {"title": "EdgeSeq ", "type": ["definition"], "description": "EdgeSeq ", "keywords": [], "past": [6], "future": [], "id": 36, "related": []}, {"title": "g.find()", "type": ["definition"], "description": "g.find() Looking up an unknown name will yield an exception: valueError ", "keywords": [], "past": [34], "future": [], "id": 37, "related": []}]